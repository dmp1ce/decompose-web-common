# Provides common processes for web projects

DECOMPOSE_WEB_PROCESSES=( 'env' 'start_nginx_proxy' 'stop_nginx_proxy'
  'restart_nginx_proxy' 'import_tls_certificate' 'start-reverse-proxy'
  'update-production-server-to-latest' 'increment-tag' 'ssh_production' )

_decompose-process-env() {
  echo "$PROJECT_ENVIRONMENT"
  echo "PRODUCTION: $PRODUCTION"
  echo "DEVELOPMENT: $DEVELOPMENT"
}
_decompose-process-env_help() {
  echo "  Show environment setting"
}

_decompose-process-ssh_production() {
  ssh $PROJECT_PRODUCTION_SERVER_USER@$PROJECT_PRODUCTION_SERVER_IP
}
_decompose-process-ssh_production_help() {
  echo "  SSH into production"
}

_decompose-process-start_nginx_proxy() {
  local nginx_proxy_id=$(_decompose-process_nginx_proxy_id)
  if [ -n "$nginx_proxy_id" ]; then
    echo "nginx-proxy ($nginx_proxy_id) is already running"
    echo "Try stoping nginx-proxy first with 'decompose stop_nginx_proxy'"
    return 0
  fi
  docker run --label "nginx_proxy" -d -p 80:80 -p 443:443 --restart="always" -e DEFAULT_HOST="$PROJECT_NGINX_DEFAULT_HOST" -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy
}
_decompose-process-start_nginx_proxy_help() {
  echo "  Start nginx-proxy which can host multiple sites"
}

_decompose-process-stop_nginx_proxy() {
  local nginx_proxy_id=$(_decompose-process_nginx_proxy_id)
  if [ -n "$nginx_proxy_id" ]; then
    echo "Closing currently running proxy: $nginx_proxy_id"
    docker stop "$nginx_proxy_id"
  fi
}
_decompose-process-stop_nginx_proxy_help() {
  echo "  Stop nginx-proxy"
}

_decompose-process-restart_nginx_proxy() {
  local nginx_proxy_id=$(_decompose-process_nginx_proxy_id)
  if [ ! -n "$nginx_proxy_id" ]; then
    echo "nginx-proxy is not running"
    echo -n "Starting nginx-proxy... "
    _decompose-process-start_nginx_proxy
    return 0
  else
    echo -n "Restarting nginx_proxy ... "
    local restart_output=$(docker restart $nginx_proxy_id)
  fi
  echo "done"
}

_decompose-process-restart_nginx_proxy_help() {
  echo "  Restart nginx-proxy"
}

_decompose-process-import_tls_certificate() {
  local key_file=$1
  local certificate_file=$2
  if [ ! -f "$key_file" ]; then
    echo "File '$key_file' does not exist"
    exit 1
  fi
  if [ ! -f "$certificate_file" ]; then
    echo "File '$certificate_file' does not exist"
    exit 1
  fi

  local cid=$(_decompose-process_nginx_proxy_id)
  if [ ! -n "$cid" ]; then
    echo "nginx-proxy is not running"
    echo "First start nginx-proxy with 'deocmpose start_nginx_proxy'"
    return 1
  fi

  echo "NOTICE: Make sure the key and certificate files use VIRTUAL_HOST names."
  echo "Example: 'foo.bar.com.crt' and 'foo.bar.com.key'"

  docker cp "$key_file" $cid:/etc/nginx/certs
  docker cp "$certificate_file" $cid:/etc/nginx/certs
  docker restart $cid
  echo "done"
}
_decompose-process-import_tls_certificate_help() {
  echo "  Import TLS certificate and key to nginx-proxy"
  echo "  Parameters:"
  echo "    1: key"
  echo "    2: certificate"
  echo "NOTICE: Make sure the key and certificate files use VIRTUAL_HOST names."
  echo "Example: 'foo.bar.com.crt' and 'foo.bar.com.key'"
}

_decompose-process-start-reverse-proxy() {
  echo "Setting up reverse proxy at:"
  echo "http://$PROJECT_REVERSE_PROXY_IP:$PROJECT_REVERSE_PROXY_PORT/"
  ssh -R $PROJECT_REVERSE_PROXY_PORT:$PROJECT_WEBSITE_TO_EXPOSE_IP:$PROJECT_WEBSITE_TO_EXPOSE_PORT $PROJECT_REVERSE_PROXY_USER@$PROJECT_REVERSE_PROXY_IP
}
_decompose-process-start-reverse-proxy_help() {
  echo "  Start a reverse proxy for testing IPNs and exposing local environment"
}

_decompose-process-increment-tag() {
  # Verify that there are no version tags on at HEAD
  # so we don't create more tags than we need
  local head_version_tag=$(__decompose-process-latest-version-tag)

  if [ $head_version_tag ]; then
    echo "The version '$head_version_tag' already exists for HEAD"
    return 1
  fi

  # Increment tag
  local newtag=$(git describe --abbrev=0 --tags --match=v* | awk -F. -v OFS=. 'NF==1{print ++$NF}; NF>1{if(length($NF+1)>length($NF))$(NF-1)++; $NF=sprintf("%0*d", length($NF), ($NF+1)%(10^length($NF))); print}')

  git tag "$newtag"
}
_decompose-process-increment-tag_help() {
  echo "  Increments the last tag and creates a new tag in git"
}

_decompose-process-update-production-server-to-latest() {
  # Test that user can update production git repository successfully
  echo "Testing user access to server:"
  echo "$PROJECT_PRODUCTION_SERVER_USER@$PROJECT_PRODUCTION_SERVER_IP:$PROJECT_PRODUCTION_SERVER_BASE_PATH"
  __decompose-process-update-production-repo || local fetch_failed=1
  if [ $fetch_failed ]; then
    echo "Access test failed!"
    echo "Check your SSH access to the production server and source control."
    exit 1
  else
    echo "Access test passed."
  fi

  # Increment the last tag
  echo "Incrementing version tag..."
  _decompose-process-increment-tag

  # Push production to source control server
  echo "Pushing local changes to source control server..."
  git push && git push --tags

  # Run ssh command to update server
  echo "Rebuilding production environment..."
  local latest_version_tag=$(__decompose-process-latest-version-tag)
  __decompose-process-update-production-repo $latest_version_tag
  __decompose-process-ssh-command "decompose build && decompose up"

  echo "Done."
}
_decompose-process-update-production-server-to-latest_help() {
  echo "  Update production to the latest code with the folloing steps:"
  echo "  -------------------------------------------------------------"
  echo "  1. Test connection to server"
  echo "  2. Create new tag, incremented from the last tag"
  echo "  3. Push latest code and tags"
  echo "  4. Update code on production site"
  echo "  5. Rebuild/recreate production containers"
}

# Parameters
#   $1: command
__decompose-process-ssh-command() {
  ssh $PROJECT_PRODUCTION_SERVER_USER@$PROJECT_PRODUCTION_SERVER_IP \
    "cd $PROJECT_PRODUCTION_SERVER_BASE_PATH && $1"
}

# Parameters
#   #1: branch, tag or hash to checkout
__decompose-process-update-production-repo() {
  __decompose-process-ssh-command "git fetch && git checkout $1 && git submodule update --init --recursive"
}

# Print the latest version tag in repository. Pattern: vA.B.C
__decompose-process-latest-version-tag() {
  echo $(git describe --tags --candidates=0 --match=v* 2> /dev/null)
}

# Echo the nginx-proxy docker id
_decompose-process_nginx_proxy_id() {
  echo $(docker ps --filter "label=nginx_proxy" --format "{{.ID}}")
}

# vim:syntax=sh
